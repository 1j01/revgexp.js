(function(){var require = function (file, cwd) {
    var resolved = require.resolve(file, cwd || '/');
    var mod = require.modules[resolved];
    if (!mod) throw new Error(
        'Failed to resolve module ' + file + ', tried ' + resolved
    );
    var cached = require.cache[resolved];
    var res = cached? cached.exports : mod();
    return res;
};

require.paths = [];
require.modules = {};
require.cache = {};
require.extensions = [".js",".coffee",".json"];

require._core = {
    'assert': true,
    'events': true,
    'fs': true,
    'path': true,
    'vm': true
};

require.resolve = (function () {
    return function (x, cwd) {
        if (!cwd) cwd = '/';
        
        if (require._core[x]) return x;
        var path = require.modules.path();
        cwd = path.resolve('/', cwd);
        var y = cwd || '/';
        
        if (x.match(/^(?:\.\.?\/|\/)/)) {
            var m = loadAsFileSync(path.resolve(y, x))
                || loadAsDirectorySync(path.resolve(y, x));
            if (m) return m;
        }
        
        var n = loadNodeModulesSync(x, y);
        if (n) return n;
        
        throw new Error("Cannot find module '" + x + "'");
        
        function loadAsFileSync (x) {
            x = path.normalize(x);
            if (require.modules[x]) {
                return x;
            }
            
            for (var i = 0; i < require.extensions.length; i++) {
                var ext = require.extensions[i];
                if (require.modules[x + ext]) return x + ext;
            }
        }
        
        function loadAsDirectorySync (x) {
            x = x.replace(/\/+$/, '');
            var pkgfile = path.normalize(x + '/package.json');
            if (require.modules[pkgfile]) {
                var pkg = require.modules[pkgfile]();
                var b = pkg.browserify;
                if (typeof b === 'object' && b.main) {
                    var m = loadAsFileSync(path.resolve(x, b.main));
                    if (m) return m;
                }
                else if (typeof b === 'string') {
                    var m = loadAsFileSync(path.resolve(x, b));
                    if (m) return m;
                }
                else if (pkg.main) {
                    var m = loadAsFileSync(path.resolve(x, pkg.main));
                    if (m) return m;
                }
            }
            
            return loadAsFileSync(x + '/index');
        }
        
        function loadNodeModulesSync (x, start) {
            var dirs = nodeModulesPathsSync(start);
            for (var i = 0; i < dirs.length; i++) {
                var dir = dirs[i];
                var m = loadAsFileSync(dir + '/' + x);
                if (m) return m;
                var n = loadAsDirectorySync(dir + '/' + x);
                if (n) return n;
            }
            
            var m = loadAsFileSync(x);
            if (m) return m;
        }
        
        function nodeModulesPathsSync (start) {
            var parts;
            if (start === '/') parts = [ '' ];
            else parts = path.normalize(start).split('/');
            
            var dirs = [];
            for (var i = parts.length - 1; i >= 0; i--) {
                if (parts[i] === 'node_modules') continue;
                var dir = parts.slice(0, i + 1).join('/') + '/node_modules';
                dirs.push(dir);
            }
            
            return dirs;
        }
    };
})();

require.alias = function (from, to) {
    var path = require.modules.path();
    var res = null;
    try {
        res = require.resolve(from + '/package.json', '/');
    }
    catch (err) {
        res = require.resolve(from, '/');
    }
    var basedir = path.dirname(res);
    
    var keys = (Object.keys || function (obj) {
        var res = [];
        for (var key in obj) res.push(key);
        return res;
    })(require.modules);
    
    for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (key.slice(0, basedir.length + 1) === basedir + '/') {
            var f = key.slice(basedir.length);
            require.modules[to + f] = require.modules[basedir + f];
        }
        else if (key === basedir) {
            require.modules[to] = require.modules[basedir];
        }
    }
};

(function () {
    var process = {};
    var global = typeof window !== 'undefined' ? window : {};
    var definedProcess = false;
    
    require.define = function (filename, fn) {
        if (!definedProcess && require.modules.__browserify_process) {
            process = require.modules.__browserify_process();
            definedProcess = true;
        }
        
        var dirname = require._core[filename]
            ? ''
            : require.modules.path().dirname(filename)
        ;
        
        var require_ = function (file) {
            var requiredModule = require(file, dirname);
            var cached = require.cache[require.resolve(file, dirname)];

            if (cached && cached.parent === null) {
                cached.parent = module_;
            }

            return requiredModule;
        };
        require_.resolve = function (name) {
            return require.resolve(name, dirname);
        };
        require_.modules = require.modules;
        require_.define = require.define;
        require_.cache = require.cache;
        var module_ = {
            id : filename,
            filename: filename,
            exports : {},
            loaded : false,
            parent: null
        };
        
        require.modules[filename] = function () {
            require.cache[filename] = module_;
            fn.call(
                module_.exports,
                require_,
                module_,
                module_.exports,
                dirname,
                filename,
                process,
                global
            );
            module_.loaded = true;
            return module_.exports;
        };
    };
})();


require.define("path",Function(['require','module','exports','__dirname','__filename','process','global'],"function filter (xs, fn) {\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (fn(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length; i >= 0; i--) {\n    var last = parts[i];\n    if (last == '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Regex to split a filename into [*, dir, basename, ext]\n// posix version\nvar splitPathRe = /^(.+\\/(?!$)|\\/)?((?:.+?)?(\\.[^.]*)?)$/;\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\nvar resolvedPath = '',\n    resolvedAbsolute = false;\n\nfor (var i = arguments.length; i >= -1 && !resolvedAbsolute; i--) {\n  var path = (i >= 0)\n      ? arguments[i]\n      : process.cwd();\n\n  // Skip empty and invalid entries\n  if (typeof path !== 'string' || !path) {\n    continue;\n  }\n\n  resolvedPath = path + '/' + resolvedPath;\n  resolvedAbsolute = path.charAt(0) === '/';\n}\n\n// At this point the path should be resolved to a full absolute path, but\n// handle relative paths to be safe (might happen when process.cwd() fails)\n\n// Normalize the path\nresolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\nvar isAbsolute = path.charAt(0) === '/',\n    trailingSlash = path.slice(-1) === '/';\n\n// Normalize the path\npath = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n  \n  return (isAbsolute ? '/' : '') + path;\n};\n\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    return p && typeof p === 'string';\n  }).join('/'));\n};\n\n\nexports.dirname = function(path) {\n  var dir = splitPathRe.exec(path)[1] || '';\n  var isWindows = false;\n  if (!dir) {\n    // No dirname\n    return '.';\n  } else if (dir.length === 1 ||\n      (isWindows && dir.length <= 3 && dir.charAt(1) === ':')) {\n    // It is just a slash or a drive letter with a slash\n    return dir;\n  } else {\n    // It is a full dirname, strip trailing slash\n    return dir.substring(0, dir.length - 1);\n  }\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPathRe.exec(path)[2] || '';\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPathRe.exec(path)[3] || '';\n};\n\nexports.relative = function(from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\n//@ sourceURL=path"
));

require.define("__browserify_process",Function(['require','module','exports','__dirname','__filename','process','global'],"var process = module.exports = {};\n\nprocess.nextTick = (function () {\n    var canSetImmediate = typeof window !== 'undefined'\n        && window.setImmediate;\n    var canPost = typeof window !== 'undefined'\n        && window.postMessage && window.addEventListener\n    ;\n\n    if (canSetImmediate) {\n        return function (f) { return window.setImmediate(f) };\n    }\n\n    if (canPost) {\n        var queue = [];\n        window.addEventListener('message', function (ev) {\n            if (ev.source === window && ev.data === 'browserify-tick') {\n                ev.stopPropagation();\n                if (queue.length > 0) {\n                    var fn = queue.shift();\n                    fn();\n                }\n            }\n        }, true);\n\n        return function nextTick(fn) {\n            queue.push(fn);\n            window.postMessage('browserify-tick', '*');\n        };\n    }\n\n    return function nextTick(fn) {\n        setTimeout(fn, 0);\n    };\n})();\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\n\nprocess.binding = function (name) {\n    if (name === 'evals') return (require)('vm')\n    else throw new Error('No such module. (Possibly not yet loaded)')\n};\n\n(function () {\n    var cwd = '/';\n    var path;\n    process.cwd = function () { return cwd };\n    process.chdir = function (dir) {\n        if (!path) path = require('path');\n        cwd = path.resolve(dir, cwd);\n    };\n})();\n\n//@ sourceURL=__browserify_process"
));

require.define("/lib/utils.js",Function(['require','module','exports','__dirname','__filename','process','global'],"function clone(src) {\n  function mixin(dest, source, copyFunc) {\n    var name, s, i, empty = {};\n    for(name in source){\n      // the (!(name in empty) || empty[name] !== s) condition avoids copying properties in \"source\"\n      // inherited from Object.prototype.   For example, if dest has a custom toString() method,\n      // don't overwrite it with the toString() method that source inherited from Object.prototype\n      s = source[name];\n      if(!(name in dest) || (dest[name] !== s && (!(name in empty) || empty[name] !== s))){\n        dest[name] = copyFunc ? copyFunc(s) : s;\n      }\n    }\n    return dest;\n  }\n\n  if(!src || typeof src != \"object\" || Object.prototype.toString.call(src) === \"[object Function]\"){\n    // null, undefined, any non-object, or function\n    return src;  // anything\n  }\n  if(src.nodeType && \"cloneNode\" in src){\n    // DOM Node\n    return src.cloneNode(true); // Node\n  }\n  if(src instanceof Date){\n    // Date\n    return new Date(src.getTime());  // Date\n  }\n  if(src instanceof RegExp){\n    // RegExp\n    return new RegExp(src);   // RegExp\n  }\n  var r, i, l;\n  if(src instanceof Array){\n    // array\n    r = [];\n    for(i = 0, l = src.length; i < l; ++i){\n      if(i in src){\n        r.push(clone(src[i]));\n      }\n    }\n    // we don't clone functions for performance reasons\n    //    }else if(d.isFunction(src)){\n    //      // function\n    //      r = function(){ return src.apply(this, arguments); };\n  }else{\n    // generic objects\n    r = src.constructor ? new src.constructor() : {};\n  }\n  return mixin(r, src, clone);\n}\n\nexports.clone = clone;\n//@ sourceURL=/lib/utils.js"
));

require.define("/lib/exec.js",Function(['require','module','exports','__dirname','__filename','process','global'],"// Whole-script strict mode syntax\n\"use strict\";\n\nvar utils = require('./utils');\nvar parse = require('./parser').parse;\n\n\nvar idCounter = 0;\n\nfunction Node(type) {\n    this.id = idCounter++;\n    this.type = type;\n}\n\nNode.prototype.patch = function (nextA, nextB) {\n    this.nextA = nextA;\n    this.nextB = nextB;\n};\n\nNode.prototype.match = function (state) {\n    if (this.match(state)) {\n        if (this.isEnd) {\n            return true;\n        }\n        var newState = state.nextChar();\n        var left = this.nextA.match(newState);\n        if (!left && this.nextB) {\n            return this.nextB.match(newState);\n        }\n    }\n    return false;\n};\n\nNode.EMPTY = 'EMPTY';\nNode.CHAR = 'CHAR';\nNode.CHARSET = 'CHARSET';\nNode.ALTR = 'ALTR';\nNode.JOIN = 'JOIN';\nNode.GROUP_BEGIN = 'GROUP_BEGIN';\nNode.GROUP_END = 'GROUP_END';\nNode.REPEAT = 'REPEAT';\nNode.NOT_MATCH = 'NOT_MATCH';\nNode.FUNC = 'FUNC';\n\nvar idCounterTrace = 0;\n\nfunction TraceEntry(pos, node, previous) {\n    this.id = idCounterTrace++;\n    this.pos = pos;\n    this.node = node;\n    this.notes = [];\n    this.children = [];\n    this.previous = previous;\n}\n\nTraceEntry.prototype = {\n    addNote: function(pos, node, comment) {\n        this.notes.push(node);\n    }\n}\n\nfunction Trace(parent, pos, node) {\n    this.id = idCounterTrace++;\n\n    if (!parent) {\n        this.traceHash = {};\n        this.traceTail = [];\n    } else {\n        this.traceHash = parent.traceHash;\n        this.traceTail = parent.traceTail;\n    }\n\n    this.pos = pos;\n    this.node = node;\n    this.parent = parent || null;\n    this.finalTrace = false;\n    this.lastItem = null;\n    this.children = [];\n    this.addToTraceHash(this);\n\n    if (parent) {\n        this.previous = this.parent.lastItem;\n    }\n}\n\nTrace.prototype = {\n    addToTraceHash: function(item) {\n        this.traceHash[item.id] = item;\n    },\n\n    createChild: function(pos, node) {\n        var child = new Trace(this, pos, node);\n        this.lastItem = child;\n        this.children.push(child);\n        return child;\n    },\n\n    record: function(pos, node) {\n        var previousItem = this.lastItem || this.parent.lastItem;\n        this.lastItem = new TraceEntry(pos, node, previousItem);\n        this.addToTraceHash(this.lastItem);\n        this.children.push(this.lastItem);\n    },\n\n    fail: function() {\n        this.failed = true;\n        this.lastItem.failed = true;\n        this.traceTail.push(this.lastItem);\n    },\n\n    success: function() {\n        this.traceTail.push(this.lastItem);\n        this.lastItem.matched = true;\n\n        // Set `finalTrace` on this trace and all it's parent traces\n        // to true.\n        var parent = this;\n        while (parent) {\n            parent.finalTrace = true;\n            parent = parent.parent;\n        }\n    },\n\n    comment: function(pos, node, comment) {\n        this.lastItem.addNote(pos, node, comment);\n    }\n}\n\nfunction State(str, regExpStr, trace) {\n    this.str = str;\n    this.regExpStr = regExpStr;\n    this.idx = 0;\n    this.matches = [];\n    this.data = {}; // TODO: Is this used anymore?\n    this.counts = {};\n    this.trace = trace || new Trace(null);\n}\n\nState.prototype.incr = function() {\n    this.idx += 1;\n};\n\nState.prototype.beginning = function() {\n    return this.idx === 0;\n}\n\nState.prototype.finished = function() {\n    return this.idx >= this.str.length;\n};\n\nState.prototype.getCurrentChar = function() {\n    return this.str[this.idx];\n};\n\nState.prototype.nodeToString = function(node) {\n    var parseEntry = node.parseEntry;\n    if (parseEntry != null && this.regExpStr != null) {\n        return this.regExpStr.substring(parseEntry.from, parseEntry.to);\n    } else {\n        return 'UNSPECIFIED';\n    }\n}\n\nState.prototype.clone = function(node, parentNode) {\n    var cloned = new State(\n        this.str,\n        this.regExpStr,\n        this.trace.createChild(this.idx, parentNode)\n    );\n    cloned.idx = this.idx;\n    cloned.matches = this.matches.slice(0, this.matches.length)\n    cloned.counts = utils.clone(this.counts);\n    cloned.data = utils.clone(this.data);\n    return cloned;\n};\n\nState.prototype.resetMatch = function(idx) {\n    this.matches[idx] = undefined;\n}\n\nState.prototype.recordMatch = function(idx, from, to) {\n    this.matches[idx] = this.str.substring(from, to);\n};\n\nState.prototype.set = function(key, value) {\n    this.data[key] = value;\n};\n\nState.prototype.get = function(key) {\n    return this.data[key];\n};\n\nState.prototype.matchString = function(str) {\n    var doMatch = this.str.indexOf(str, this.idx) === this.idx;\n    if (doMatch) {\n        this.idx += str.length;\n    }\n    return doMatch;\n};\n\nState.prototype.incCounts = function(idx) {\n    var oldValue = this.counts[idx] === undefined ? -1 : this.counts[idx];\n    return this.counts[idx] = oldValue + 1;\n};\n\nState.prototype.isWordChar = function(offset) {\n    var idx = this.idx + offset;\n    if (idx === -1 || idx === this.str.length) return false;\n    return /[a-zA-Z0-9_]/.test(this.str[idx]);\n}\n\n// Things to record a trace on the state.\nState.prototype.try = function(node) {\n    this.trace.record(this.idx, node)\n};\n\nState.prototype.comment = function(node, comment) {\n    this.trace.comment(this.idx, node, comment);\n};\n\nState.prototype.fail = function() {\n    this.trace.fail(this.idx);\n    return false;\n};\n\nState.prototype.success = function() {\n    this.trace.success();\n}\n\nfunction match(state, node) {\n    function fork(parentNode, childNode, resetMatches) {\n        var forkedState = state.clone(childNode, parentNode);\n        \n        if (resetMatches) {\n            resetRepeatMaches(node, forkedState);\n        }\n\n        return match(forkedState, childNode);\n    }\n\n    function resetRepeatMaches(node, stateToReset) {\n        var parseEntry = node.parseEntry;\n        if (parseEntry && parseEntry.firstMatchIdx != null && parseEntry.firstMatchIdx >= 0) {\n            for (var i = parseEntry.firstMatchIdx; i <= parseEntry.lastMatchIdx; i++) {\n                stateToReset.resetMatch(i);\n            }\n        }\n    }\n\n    var res;\n    while (node) {\n        var nextChar = state.getCurrentChar();\n\n        if (node.type !== Node.REPEAT)\n            state.try(node);\n\n        switch (node.type) {\n            case Node.FUNC:\n                if (!node.func(state)) {\n                    return state.fail();\n                }\n                node = node.next;\n                break;\n\n            case Node.REPEAT:\n                var lastIdx = state.get(node.id);\n                if (lastIdx !== undefined && lastIdx === state.idx) {\n                    // Have the case of an empty match. No process is made\n                    // no mather how often this repetition is applied. Therefore\n                    // continue with the next node right away.\n                    state.set(node.id, undefined);\n                    return match(state, node.next);\n                } else {\n                    state.set(node.id, state.idx);\n                }\n\n                // StateCounters start at -1 -> first inc makes the counter be zero.\n                var counter = state.incCounts(node.id);\n                if (counter < node.min) {\n                    resetRepeatMaches(node, state);\n                    state.try(node);\n                    state.comment(node, 'Need to repeat another time');\n                    // Haven't matched the minimum number yet\n                    // -> match one more time.\n                    res = match(state, node.child);\n                } else if (counter === node.max) {\n                    // Have matched the maximum number\n                    // -> nothing to change.\n                    res = state;\n                } else {\n                    // match \\in {from, to}\n                    if (node.greedy) {\n                        // 15.10.2.5: Greedy - repeat child as many times as possible.\n                        res = fork(node, node.child, true);\n                        if (!res) {\n                            res = match(state, node.next);\n                        }\n                    } else {\n                        // 15.10.2.5: non-greedy - repeat child as less times as possible.\n                        res = fork(node, node.next);\n                        if (!res) {\n                            resetRepeatMaches(node, state);\n                            res = match(state, node.child);\n                        }\n                    }\n                }\n                if (!res) {\n                    return state.fail();\n                }\n                return res;\n\n            case Node.CHARSET:\n                if (state.finished()) {\n                    return false;\n                }\n\n                if (node.children.length !== 0) {\n                    res = node.children.some(function(f) {\n                        return f(nextChar);\n                    });\n                } else {\n                    res = true;\n                }\n\n\n                if (node.not) {\n                    res = !res;\n                }\n\n                if (res) {\n                    state.incr();\n                    node = node.next;\n                } else {\n                    state.fail();\n                    return false;\n                }\n                break;\n\n\n            case Node.CHAR:\n                if (state.finished()) {\n                    return false;\n                }\n\n                if (node.data === nextChar) {\n                    state.incr();\n                    node = node.next;\n                } else {\n                    state.fail();\n                    return false;\n                }\n                break;\n            case Node.ALTR:\n                for (var i = 0; i < node.children.length; i++) {\n                    res = fork(node, node.children[i]);\n                    if (res) {\n                        return res;\n                    }\n                }\n                return null;\n\n            case Node.EMPTY:\n            case Node.JOIN:\n                node = node.next;\n                break;\n\n            case Node.GROUP_BEGIN:\n                state.set(node.matchIdx, state.idx);\n\n                node = node.next;\n                break;\n\n            case Node.GROUP_END:\n                // If node.idx > 0, then it's a group to store the match.\n                if (node.matchIdx >= 0) {\n                    var beginState = state.get(node.matchIdx);\n                    state.recordMatch(node.matchIdx, beginState, state.idx);\n                }\n\n                // node.data === -1 // don't remember the match\n\n                // Case of: x(?=y)\n                if (node.matchIdx < -1) {\n                    state.idx = state.get(node.matchIdx);\n                }\n\n                node = node.next;\n                break;\n\n            case Node.NOT_MATCH:\n                // Case of: x(?!y)\n                res = fork(node, node.child);\n                if (res) {\n                    return false;\n                }\n                node = node.next;\n                break;\n\n            default:\n                throw \"Unkown node type: \" + node.type;\n\n        }\n    }\n\n    if (node) {\n        return false;\n    }\n\n    state.success();\n\n    return state;\n}\n\nfunction retArr(nodes) {\n    return [nodes[0], nodes[nodes.length - 1]];\n}\n\nfunction bText(str) {\n    var nodeA, nodeB;\n\n    if (str === '') {\n        nodeA = new Node(Node.EMPTY);\n        return [nodeA, nodeA];\n    } else if (str.length === 1) {\n        nodeA = new Node(Node.CHAR);\n        nodeA.data = str;\n        return [nodeA, nodeA];\n    }\n\n    var nodes = str.split('').map(function(ch, idx) {\n        var node = new Node(Node.CHAR, idx, idx + 1);\n        node.data = ch;\n        return node;\n    });\n    for (var i = 0; i < nodes.length - 1; i++) {\n        nodes[i].next = nodes[i + 1];\n    }\n\n    return retArr(nodes);\n}\n\n// If group should be a not-remember-group like `(?:x)`, then set\n// `idx=0`.\nfunction bGroup(children, matchIdx, lastMatchIdx) {\n    if (lastMatchIdx === undefined) {\n        lastMatchIdx = matchIdx;\n    }\n\n    var begin = new Node(Node.GROUP_BEGIN);\n    var end = new Node(Node.GROUP_END);\n\n    begin.matchIdx = end.matchIdx = matchIdx;\n    begin.lastMatchIdx = end.lastMatchIdx = lastMatchIdx;\n\n    begin.next = children[0];\n    children[1].next = end;\n\n    return [begin, end];\n}\n\nfunction bFollowMatch(children) {\n    var id = idCounter++;\n    return bGroup(children, -id - 1);\n}\n\nfunction bNotFollowMatch(children) {\n    var node = new Node(Node.NOT_MATCH);\n    node.child = children[0];\n    return [node, node];\n}\n\nfunction bCharacterClass(isNegative, matches) {\n    var nodeA = new Node(Node.CHARSET);\n    nodeA.not = isNegative;\n    nodeA.children = matches;\n\n    return [nodeA, nodeA];\n}\n\nfunction bCharSet(isNot, str) {\n    var nodeA = new Node(Node.CHARSET);\n    nodeA.not = isNot;\n\n    // TODO: Add proper parsing of charSet here.\n    nodeA.children = str.split('').map(function(matchChar) {\n        return function(inputChar) {\n            return inputChar === matchChar;\n        };\n    });\n\n    return [nodeA, nodeA];\n}\n\n// BuildDot is just a shorthand for a charSet excluding all newlines.\nfunction bDot() {\n    return bCharSet(true, '\\n\\r\\u2028\\u2029');\n}\n\nfunction bBoundary(isNegative) {\n    return bFunc(function(state) {\n        // See: 15.10.2.6\n        var a = state.isWordChar(-1);\n        var b = state.isWordChar(0);\n        res = (a === true && b === false) || (a === false && b === true);\n        if (isNegative) {\n            res = !res;\n        }\n        return res;\n    })\n}\n\nfunction bFunc(func) {\n    var node = new Node(Node.FUNC);\n    node.func = func;\n    return [node, node];\n}\n\nfunction buildNodeFromRegStr(str) {\n    return walk(parse(str), false);\n}\n\n\n// TAKEN FROM ESPRIMA! BEGIN >>\n\n// 7.2 White Space\n\nfunction isWhiteSpace(ch) {\n    return (ch === 32) ||  // space\n        (ch === 9) ||      // tab\n        (ch === 0xB) ||\n        (ch === 0xC) ||\n        (ch === 0xA0) ||\n        (ch >= 0x1680 && '\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\uFEFF'.indexOf(String.fromCharCode(ch)) > 0);\n}\n\n// 7.3 Line Terminators\n\nfunction isLineTerminator(ch) {\n    return (ch === 10) || (ch === 13) || (ch === 0x2028) || (ch === 0x2029);\n}\n\n// TAKEN FROM ESPRIMA! << END\n\nfunction buildWhitespaceLineOrTerminator(negative) {\n    // The functions taken from esprima expect to get the charCode of the\n    // character. Therefore wrap the functions, such that the input string\n    // gets converted to an integer before calling the funciton.\n    function strToChar(func) {\n        return function(input) {\n            return func(input.charCodeAt(0));\n        }\n    }\n\n    return bCharacterClass(negative, [\n        strToChar(isWhiteSpace),\n        strToChar(isLineTerminator)\n    ]);\n}\n\nvar escapedChars = {\n    // The build functions are wrapped in a function to create a fresh node\n    // for every escapedChar. Otherwise setting the `next` property on a\n    // node used at multiple places fails.\n    't': function() { return buildNodeFromRegStr('\\\\u0009'); },\n    'n': function() { return buildNodeFromRegStr('\\\\u000A'); },\n    'v': function() { return buildNodeFromRegStr('\\\\u000B'); },\n    'f': function() { return buildNodeFromRegStr('\\\\u000C'); },\n    'r': function() { return buildNodeFromRegStr('\\\\u000D'); },\n    'd': function() { return buildNodeFromRegStr('[0-9]'); },\n    'D': function() { return buildNodeFromRegStr('[^0-9]'); },\n    'w': function() { return buildNodeFromRegStr('[A-Za-z0-9_]'); },\n    'W': function() { return buildNodeFromRegStr('[^A-Za-z0-9_]'); },\n    's': function() { return buildWhitespaceLineOrTerminator(false); },\n    'S': function() { return buildWhitespaceLineOrTerminator(true); },\n    'b': function() { return bBoundary(false); },\n    'B': function() { return bBoundary(true) }\n}\nfunction bEscapedChar(value) {  // 15.10.2.12\n    if (value in escapedChars) {\n        return escapedChars[value]();\n    } else {\n        throw new Error('Unkown escaped char: ' + value);\n    }\n}\n\nfunction bAlt() {\n    var altr = new Node(Node.ALTR);\n    var join = new Node(Node.JOIN);\n\n    var children = Array.prototype.slice.call(arguments, 0);\n    altr.children = children.map(function(list) {\n        list[1].next = join;\n        return list[0];\n    });\n\n    return [altr, join];\n}\n\nfunction bJoin() {\n    var args = arguments;\n\n    for (var i = 0; i < args.length - 1; i++) {\n        args[i][1].next = args[i + 1][0];\n    }\n\n    return [args[0][0], args[args.length - 1][1]];\n}\n\n\nfunction bRepeat(greedy, min, max, children) {\n    var node = new Node(Node.REPEAT);\n\n    node.greedy = greedy;\n    node.min = min;\n    node.max = max;\n\n    // Create a loop.\n    node.child = children[0];\n    children[1].next = node;\n\n    return [node, node];\n}\n\nfunction bEmpty() {\n    var node = new Node(Node.EMPTY);\n    return [node, node];\n}\n\nfunction runTests() {\n    test('dabc', bJoin(\n        bDot(),\n        bGroup(\n            bAlt(\n                bText(''),\n                bText('a')\n            ),\n            1\n        ),\n        bText('bc')\n    ), 4, ['dabc', 'a']);\n\n    test('abab', bJoin(\n        bRepeat(true, 0, 100, bDot()),\n        bGroup(\n            bText('b'),\n            1\n        )\n    ), 4, ['abab', 'b']);\n\n    test('abab', bJoin(\n        bRepeat(false, 0, 100, bDot()),\n        bGroup(\n            bText('b'),\n            1\n        )\n    ), 2, ['ab', 'b']);\n\n    test('abcabd', bJoin(\n        bGroup(\n            bText('abd'),\n            1\n        )\n    ), 6, ['abd', 'abd']);\n\n    test('abcabd', bGroup(bJoin(\n        bText('b'),\n        bFollowMatch(\n            bText('d')\n        )\n    ), 1), 5, ['b', 'b']);\n\n    test('abcabd', bGroup(bJoin(\n        bText('b'),\n        bNotFollowMatch(\n            bText('c')\n        )\n    ), 1), 5, ['b', 'b']);\n\n\n}\n\nfunction nodeToCharCode(node) {\n    switch (node.type) {\n        case 'character':\n            return node.char.charCodeAt(0);\n\n        case 'escape':\n            switch (node.name) {\n                case 'unicode':\n                    return parseInt(node.value, 16);\n                default:\n                    throw new Error('Unsupported node escape name: ' + node.name);\n            }\n    }\n\n    return null;\n}\n\nfunction nodeToChar(node) {\n    var code = nodeToCharCode(node);\n    if (code === null) {\n        return null;\n    }\n    return String.fromCharCode(code);\n}\n\nfunction buildClassMatcher(entry) {\n    switch (entry.type) {\n        case 'character':\n        case 'escape':\n            var ch = nodeToChar(entry);\n            return function(input) {\n                return ch === input;\n            }\n            break;\n\n        case 'characterClassRange':\n            var min = nodeToCharCode(entry.min);\n            var max = nodeToCharCode(entry.max);\n\n            if (max < min) {\n                // TODO: Better error message.\n                throw new Error('Character not in right order');\n            }\n            return function(input) {\n                var ch = input.charCodeAt(0);\n                return ch >= min && ch <= max;\n            }\n\n        case 'empty':\n            return function(input) { return true; }\n\n        case 'escapeChar':\n            return function(input) {\n                // escapeChar are made up of RegExp again. Do the simpliest way\n                // possible ATM and test the escapeChar against the input string\n                // using the match function itself again ;)\n                // This is not a problem, as escapeChars don't have circular\n                // dependencies.\n                var state = new State(input);\n                var firstNode = bEscapedChar(entry.value)[0];\n                return !!match(state, firstNode);\n            }\n\n        default:\n            throw new Error('Unkown classRange entry type: ' + entry.type);\n    }\n}\n\nvar groupCounter = 1;\nfunction walk(node, inCharacterClass) {\n    var arr;\n    var res;\n    switch (node.type) {\n        case 'disjunction':\n            arr = node.alternatives.map(walk);\n            res = bAlt.apply(null, arr);\n            break;\n\n        case 'alternative':\n            arr = node.terms.map(walk);\n            // Return here directly and don't finish the funciton. This way\n            // the parseEntry of the `alternative` is not set.\n            return  bJoin.apply(null, arr);\n\n        case 'character':\n        case 'escape':\n            res = bText(nodeToChar(node));\n            break;\n\n        case 'escapeChar':\n            res = bEscapedChar(node.value);\n            break;\n\n        case 'quantifier':\n            res = bRepeat(node.greedy, node.min, node.max, walk(node.child));\n            res.firstMatchIdx = node.firstMatchIdx;\n            res.lastMatchIdx = node.lastMatchIdx;\n            break;\n\n        case 'group':\n            res = walk(node.disjunction);\n            if (node.behavior === 'onlyIfNot') {\n                res = bNotFollowMatch(res);\n            } else {\n                var idx;\n                var endIdx;\n                if (node.behavior === 'onlyIf') {\n                    idx = -2;\n                } else if (node.behavior === 'ignore') {\n                    idx = -1;\n                } else {\n                    idx = node.matchIdx;\n                    endIdx = node.lastMatchIdx;\n                }\n                res = bGroup(res, idx, endIdx);\n            }\n\n            res[1].parseEntry = node;\n            break;\n\n        case 'characterClass':\n            var matcher = node.classRanges.map(buildClassMatcher);\n            res = bCharacterClass(node.negative, matcher);\n            break;\n\n        case 'empty':\n            res = bEmpty();\n            break;\n\n        case 'dot':\n            res = bDot();\n            break;\n\n        case 'assertion':\n            if (node.sub === 'start') {\n                res = bFunc(function(state) {\n                    return state.beginning();\n                });\n            } else {\n                res = bFunc(function(state) {\n                    return state.finished();\n                });\n            }\n            break;\n\n        case 'ref':\n            res = bFunc(function(state) {\n                var refMatch = state.matches[node.ref];\n                if (refMatch === undefined) {\n                    throw new Error('Accessing match that is not set.');\n                }\n                state.comment(null, 'referenced value: ' + refMatch);\n                return state.matchString(refMatch);\n            });\n            break;\n\n        default:\n            throw new Error('Unsupported node type: ' + node.type);\n    }\n    res[0].parseEntry = node;\n    return res;\n}\n\nfunction buildFakeParseEntry(from, to, bit) {\n    return {\n        from: from,\n        to: to,\n        bit: bit,\n        booting: true\n    };\n}\n\nfunction getStartNodeFromPattern(regExpStr) {\n    idCounter = 0;\n    groupCounter = 1;\n\n    var parseTree = parse(regExpStr);\n    if (parseTree.error) {\n        throw parseTree.erro\n    }\n\n    var bootDot = bDot();\n    bootDot[0].parseEntry = buildFakeParseEntry(-3, -2, '.');\n\n    var bootRepeat = bRepeat(false, 0, undefined, bootDot);\n    bootRepeat[0].parseEntry = buildFakeParseEntry(-2, -1, '*');\n\n    var bootGroup = bGroup(walk(parseTree), 0, parseTree.lastMatchIdx);\n    var bootGroupParseEntry = buildFakeParseEntry(-1, Number.MAX_VALUE, '()');\n    bootGroup[0].parseEntry = bootGroup[1].parseEntry = bootGroupParseEntry;\n\n    var startNode = bJoin(\n        bootRepeat,\n        bootGroup\n    )[0];\n\n    startNode.regExpStr = regExpStr;\n    startNode.lastMatchIdx = parseTree.lastMatchIdx;\n    startNode.parseTree = parseTree;\n\n    return startNode;\n}\n\nfunction exec(matchStr, startNode, lastIndex) {\n    idCounterTrace = 0;\n    var regExpStr = startNode.regExpStr;\n    var lastMatchIdx = startNode.lastMatchIdx;\n\n    var trace = new Trace(null, 0, startNode);\n    var state = new State(matchStr, regExpStr, trace);\n    state.idx = lastIndex;\n    state.matches = new Array(lastMatchIdx + 1);\n    var endState = match(state, startNode);\n    endState.trace = trace;\n\n    if (!endState) {\n        endState = {};\n    } else {\n        // This is necessary as otherwise the length of the matches might fit\n        // but calling Object.keys don't return the right thing.\n        for (var i = 0; i < lastMatchIdx + 1; i++) {\n            if (endState.matches[i] === undefined) {\n                endState.matches[i] = undefined;\n            }\n        }\n    }\n\n    endState.parseTree = startNode.parseTree;\n    return endState;\n}\n\nexports.getStartNodeFromPattern = getStartNodeFromPattern;\nexports.exec = exec;\n\n//@ sourceURL=/lib/exec.js"
));

require.define("/lib/parser.js",Function(['require','module','exports','__dirname','__filename','process','global'],"// See: 15.10.1\n//\n// Pattern ::\n//      Disjunction\n//\n// Disjunction ::\n//      Alternative\n//      Alternative | Disjunction\n//\n// Alternative ::\n//      [empty]\n//      Alternative Term\n//\n// Term ::\n//      Assertion\n//      Atom\n//      Atom Quantifier\n//\n// Assertion ::\n//      ^\n//      $\n//      \\ b\n//      \\ B\n//      ( ? = Disjunction )\n//      ( ? ! Disjunction )\n//\n// Quantifier ::\n//      QuantifierPrefix\n//      QuantifierPrefix ?\n//\n// QuantifierPrefix ::\n//      *\n//      +\n//      ?\n//      { DecimalDigits }\n//      { DecimalDigits , }\n//      { DecimalDigits , DecimalDigits }\n//\n// Atom ::\n//      PatternCharacter\n//      .\n//      \\ AtomEscape\n//      CharacterClass\n//      ( Disjunction )\n//      ( ? : Disjunction )\n//\n// PatternCharacter ::\n//      SourceCharacter but not any of: ^ $ \\ . * + ? ( ) [ ] { } |\n//\n// AtomEscape ::\n//      DecimalEscape\n//      CharacterEscape\n//      CharacterClassEscape\n//\n// CharacterEscape ::\n//      ControlEscape\n//      c ControlLetter\n//      HexEscapeSequence\n//      UnicodeEscapeSequence\n//      IdentityEscape\n//\n// ControlEscape ::\n//      one of f n r t v\n// ControlLetter ::\n//      one of\n//          a b c d e f g h i j k l m n o p q r s t u v w x y z\n//          A B C D E F G H I J K L M N O P Q R S T U V W X Y Z\n//\n// IdentityEscape ::\n//      SourceCharacter but not IdentifierPart\n//      <ZWJ>\n//      <ZWNJ>\n//\n// DecimalEscape ::\n//      DecimalIntegerLiteral [lookahead ∉ DecimalDigit]\n//      CharacterClassEscape :: one of\n//      d D s S w W\n//\n// CharacterClass ::\n//      [ [lookahead ∉ {^}] ClassRanges ]\n//      [ ^ ClassRanges ]\n//\n// ClassRanges ::\n//      [empty]\n//      NonemptyClassRanges\n//\n// NonemptyClassRanges ::\n//      ClassAtom\n//      ClassAtom NonemptyClassRangesNoDash\n//      ClassAtom - ClassAtom ClassRanges\n//\n// NonemptyClassRangesNoDash ::\n//      ClassAtom\n//      ClassAtomNoDash NonemptyClassRangesNoDash\n//      ClassAtomNoDash - ClassAtom ClassRanges\n//\n// ClassAtom ::\n//      -\n//      ClassAtomNoDash\n//\n// ClassAtomNoDash ::\n//      SourceCharacter but not one of \\ or ] or -\n//      \\ ClassEscape\n//\n// ClassEscape ::\n//      DecimalEscape\n//      b\n//      CharacterEscape\n//      CharacterClassEscape\n\nfunction parse(str) {\n    var pos = 0;\n    var lastMatchIdx = 0;\n\n    function addBit(node) {\n        node.bit = str.substring(node.from, node.to);\n        return node;\n    }\n\n    function createAssertion(sub) {\n        return addBit({\n            type: 'assertion',\n            sub:  sub,\n            from: pos - 1,\n            to: pos\n        });\n    }\n\n    function createCharacter(matches) {\n        return addBit({\n            type: 'character',\n            char: matches[0],\n            from: pos - 1,\n            to: pos\n        });\n    }\n\n    function createDisjunction(alternatives, from, to) {\n        return addBit({\n            type: 'disjunction',\n            alternatives: alternatives,\n            from: from,\n            to: to\n        });\n    }\n\n    function createEmpty() {\n        return addBit({\n            type: 'empty',\n            from: pos,\n            to: pos\n        });\n    }\n\n    function createDot(name) {\n        return addBit({\n            type: 'dot',\n            from: pos - 1,\n            to: pos\n        });\n    }\n\n    function createEscaped(name, value, fromOffset) {\n        fromOffset = fromOffset || 0;\n        return addBit({\n            type: 'escape',\n            name: name,\n            value: value,\n            from: pos - (value.length + fromOffset),\n            to: pos\n        });\n    }\n\n    function createEscapedChar(value) {\n        return addBit({\n            type: 'escapeChar',\n            value: value,\n            from: pos - 2,\n            to: pos\n        });\n    }\n\n    function createRef(ref) {\n        return addBit({\n            type: 'ref',\n            ref: parseInt(ref, 10),\n            from: pos - 1 - ref.length,\n            to: pos\n        });\n    }\n\n    function createGroup(behavior, disjunction, from, to) {\n        return addBit({\n            type: 'group',\n            behavior: behavior,\n            disjunction: disjunction,\n            from: from,\n            to: to\n        });\n    }\n\n    function createQuantifier(min, max, from, to) {\n        if (to == null) {\n            from = pos - 1;\n            to = pos;\n        }\n\n        return addBit({\n            type: 'quantifier',\n            min: min,\n            max: max,\n            greedy: true,\n            child: null, // set later on,\n            from: from,\n            to: to\n        });\n    }\n\n    function createAlternative(terms, from, to) {\n        return addBit({\n            type: 'alternative',\n            terms: terms,\n            from: from,\n            to: to\n        });\n    }\n\n    function createCharacterClass(classRanges, negative, from, to) {\n        return addBit({\n            type: 'characterClass',\n            classRanges: classRanges,\n            negative: negative,\n            from: from,\n            to: to\n        });\n    }\n\n    function createClassRange(min, max, from, to) {\n        return addBit({\n            type: 'characterClassRange',\n            min: min,\n            max: max,\n            from: from,\n            to: to\n        });\n    }\n\n    function isEmpty(obj) {\n        return obj.type === 'empty';\n    }\n\n    function incr(amount) {\n        amount = (amount || 1);\n        var res = str.substring(pos, pos + amount);\n        pos += (amount || 1);\n        return res;\n    }\n\n    function skip(value) {\n        if (!match(value)) {\n            throw expected('character: ' + value);\n        }\n    }\n\n    function match(value) {\n        if (str.indexOf(value, pos) === pos) {\n            return incr(value.length);\n        }\n    }\n\n    function lookahead() {\n        return str[pos];\n    }\n\n    function current(value) {\n        return str.indexOf(value, pos) === pos;\n    }\n\n    function next(value) {\n        return str[pos + 1] === value;\n    }\n\n    function matchReg(regExp) {\n        var subStr = str.substring(pos);\n        var res = subStr.match(regExp);\n        if (res) {\n            res.from = pos;\n            incr(res[0].length);\n            res.to = pos;\n        }\n        return res;\n    }\n\n    function parseDisjunction() {\n        // Disjunction ::\n        //      Alternative\n        //      Alternative | Disjunction\n        var res = [], from = pos;\n        res.push(parseAlternative());\n\n        while (match('|')) {\n            res.push(parseAlternative());\n        }\n\n        if (res.length === 1) {\n            return res[0];\n        }\n\n        return createDisjunction(res, from, pos);\n    }\n\n    function parseAlternative() {\n        var res = [], from = pos;\n\n        // Alternative ::\n        //      [empty]\n        //      Alternative Term\n        while (term = parseTerm()) {\n            if (isEmpty(term)) {\n                // Only add Empty if there is nothing else in the result array.\n                // Otherwise ignore it to save noice in the AST.\n                if (res.length === 0) {\n                    res.push(term);\n                }\n                break;\n            }\n\n            res.push(term);\n        }\n\n        return createAlternative(res, from, pos);\n    }\n\n    function parseTerm() {\n        // Term ::\n        //      Assertion\n        //      Atom\n        //      Atom Quantifier\n\n        if (pos >= str.length || current('|') || current(')')) {\n            return createEmpty();\n        }\n\n        var assertion = parseAssertion();\n\n        if (assertion) {\n            return assertion;\n        }\n\n        var matchIdx = lastMatchIdx;\n\n        var atom = parseAtom();\n        if (!atom) {\n            throw syntaxError('Expected atom')\n            // return createEmpty();\n        }\n        var quantifier = parseQuantifier() || false;\n        if (quantifier) {\n            quantifier.child = atom;\n            if (matchIdx + 1 <= lastMatchIdx) {\n                quantifier.firstMatchIdx = matchIdx + 1;\n                quantifier.lastMatchIdx = lastMatchIdx;\n            }\n\n            return quantifier;\n        }\n        return atom;\n    }\n\n    function parseGroup(matchA, typeA, matchB, typeB) {\n        var type = null, from = pos;\n\n        if (match(matchA)) {\n            type = typeA;\n        } else if (match(matchB)) {\n            type = typeB;\n        } else {\n            return false;\n        }\n\n        var matchIdx;\n        if (type === 'normal') {\n            matchIdx = ++lastMatchIdx;\n        }\n\n        res = parseDisjunction();\n        if (!res) {\n            throw expected('disjunction');\n        }\n        skip(')');\n        var group = createGroup(type, res, from, pos);\n        if (type == 'normal') {\n            group.matchIdx = matchIdx;\n            group.lastMatchIdx = lastMatchIdx;\n        }\n        return group;\n    }\n\n    function parseAssertion() {\n        // Assertion ::\n        //      ^\n        //      $\n        //      \\ b\n        //      \\ B\n        //      ( ? = Disjunction )\n        //      ( ? ! Disjunction )\n        var res, from = pos;\n\n        if (match('^')) {\n            return createAssertion('start');\n        } else if (match('$')) {\n            return createAssertion('end');\n        } else if (res = matchReg(/^\\\\(b|B)/)) {\n            return createEscapedChar(res[1]);\n        } else {\n            return parseGroup('(?=', 'onlyIf', '(?!', 'onlyIfNot');\n        }\n    }\n\n    function parseQuantifier() {\n        // Quantifier ::\n        //      QuantifierPrefix\n        //      QuantifierPrefix ?\n        //\n        // QuantifierPrefix ::\n        //      *\n        //      +\n        //      ?\n        //      { DecimalDigits }\n        //      { DecimalDigits , }\n        //      { DecimalDigits , DecimalDigits }\n\n        var res;\n        var quantifier;\n        var min, max;\n\n        if (match('*')) {\n            quantifier = createQuantifier(0);\n        }\n        else if (match('+')) {\n            quantifier = createQuantifier(1);\n        }\n        else if (match('?')) {\n            quantifier = createQuantifier(0, 1);\n        }\n        else if (res = matchReg(/^\\{([0-9]+)\\}/)) {\n            min = parseInt(res[1], 10);\n            quantifier = createQuantifier(min, min);\n        }\n        else if (res = matchReg(/^\\{([0-9]+),\\}/)) {\n            min = parseInt(res[1], 10);\n            quantifier = createQuantifier(min, undefined, res.from, res.to);\n        }\n        else if (res = matchReg(/^\\{([0-9]+),([0-9]+)\\}/)) {\n            min = parseInt(res[1], 10);\n            max = parseInt(res[2], 10);\n            quantifier = createQuantifier(min, max, res.from, res.to);\n        }\n\n        if (quantifier) {\n            if (match('?')) {\n                quantifier.greedy = false;\n                quantifier.to += 1;\n            }\n        }\n\n        return quantifier;\n    }\n\n    function parseAtom() {\n        // Atom ::\n        //      PatternCharacter\n        //      .\n        //      \\ AtomEscape\n        //      CharacterClass\n        //      ( Disjunction )\n        //      ( ? : Disjunction )\n\n        var res;\n\n        if (res = matchReg(/^[^^$\\\\.*+?()[\\]{}|]/)) {\n            //      PatternCharacter\n            return createCharacter(res);\n        }\n        else if (match('.')) {\n            //      .\n            return createDot();\n        }\n        else if (match('\\\\')) {\n            //      \\ AtomEscape\n            var res = parseAtomEscape();\n            if (!res) {\n                throw expected('atomEscape');\n            }\n            return res;\n        }\n        else if (res = parseCharacterClass()) {\n            return res;\n        }\n        else {\n            //      ( Disjunction )\n            //      ( ? : Disjunction )\n            return parseGroup('(?:', 'ignore', '(', 'normal');\n        }\n    }\n\n    function parseClassEscape() {\n        return parseAtomEscape(true);\n    }\n\n    function parseAtomEscape(insideCharacterClass) {\n        // AtomEscape ::\n        //      DecimalEscape\n        //      CharacterEscape\n        //      CharacterClassEscape\n\n        var res;\n\n        res = parseDecimalEscape();\n        if (res) {\n            return res;\n        }\n\n        // For ClassEscape\n        if (insideCharacterClass) {\n            if (match('b')) {\n                // 15.10.2.19\n                // The production ClassEscape :: b evaluates by returning the\n                // CharSet containing the one character <BS> (Unicode value 0008).\n                return createEscaped('unicode', '0008', -2);\n            } else if (match('B')) {\n                throw syntaxError('\\\\B not possible inside of CharacterClass');\n            }\n        }\n\n        res = parseCharacterEscape();\n        if (res) {\n            return res;\n        }\n\n        res = parseCharacterClassEscape();\n        if (res) {\n            return res;\n        }\n\n        return res;\n    }\n\n\n    function parseDecimalEscape() {\n        // DecimalEscape ::\n        //      DecimalIntegerLiteral [lookahead ∉ DecimalDigit]\n        //      CharacterClassEscape :: one of\n        //      d D s S w W\n\n        var res;\n        if (match('0')) {\n            return createEscaped('null', '', 1);\n        } else if (res = matchReg(/^[0-9]+/)) {\n            return createRef(res[0]);\n        } else if (res = matchReg(/^[dDsSwW]/)) {\n            return createEscapedChar(res[0]);\n        }\n         return false;\n    }\n\n    function parseCharacterEscape() {\n        // CharacterEscape ::\n        //      ControlEscape\n        //      c ControlLetter\n        //      HexEscapeSequence\n        //      UnicodeEscapeSequence\n        //      IdentityEscape\n\n        var res;\n        if (res = matchReg(/^[fnrtv]/)) {\n        //      ControlEscape\n            return createEscapedChar(res[0]);\n        } else if (res = matchReg(/^c([a-zA-Z])/)) {\n        //      c ControlLetter\n            return createEscaped('controlLetter', res[1], 1);\n        } else if (res = matchReg(/^x([0-9a-fA-F]{2})/)) {\n        //      HexEscapeSequence\n            return createEscaped('hex', res[1], 1);\n        } else  if (res = matchReg(/^u([0-9a-fA-F]{4})/)) {\n        //      UnicodeEscapeSequence\n            return createEscaped('unicode', res[1], 1);\n        } else {\n        //      IdentityEscape\n            return parseIdentityEscape();\n        }\n    }\n\n    // Taken from the esprima parser.\n    function isIdentifierPart(ch) {\n        var NonAsciiIdentifierPart = new RegExp('[\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0300-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u0483-\\u0487\\u048a-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0610-\\u061a\\u0620-\\u0669\\u066e-\\u06d3\\u06d5-\\u06dc\\u06df-\\u06e8\\u06ea-\\u06fc\\u06ff\\u0710-\\u074a\\u074d-\\u07b1\\u07c0-\\u07f5\\u07fa\\u0800-\\u082d\\u0840-\\u085b\\u08a0\\u08a2-\\u08ac\\u08e4-\\u08fe\\u0900-\\u0963\\u0966-\\u096f\\u0971-\\u0977\\u0979-\\u097f\\u0981-\\u0983\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bc-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09ce\\u09d7\\u09dc\\u09dd\\u09df-\\u09e3\\u09e6-\\u09f1\\u0a01-\\u0a03\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a59-\\u0a5c\\u0a5e\\u0a66-\\u0a75\\u0a81-\\u0a83\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abc-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ad0\\u0ae0-\\u0ae3\\u0ae6-\\u0aef\\u0b01-\\u0b03\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3c-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b5c\\u0b5d\\u0b5f-\\u0b63\\u0b66-\\u0b6f\\u0b71\\u0b82\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd0\\u0bd7\\u0be6-\\u0bef\\u0c01-\\u0c03\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c33\\u0c35-\\u0c39\\u0c3d-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c58\\u0c59\\u0c60-\\u0c63\\u0c66-\\u0c6f\\u0c82\\u0c83\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbc-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0cde\\u0ce0-\\u0ce3\\u0ce6-\\u0cef\\u0cf1\\u0cf2\\u0d02\\u0d03\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4e\\u0d57\\u0d60-\\u0d63\\u0d66-\\u0d6f\\u0d7a-\\u0d7f\\u0d82\\u0d83\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0df2\\u0df3\\u0e01-\\u0e3a\\u0e40-\\u0e4e\\u0e50-\\u0e59\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb9\\u0ebb-\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0edc-\\u0edf\\u0f00\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e-\\u0f47\\u0f49-\\u0f6c\\u0f71-\\u0f84\\u0f86-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u1000-\\u1049\\u1050-\\u109d\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u135d-\\u135f\\u1380-\\u138f\\u13a0-\\u13f4\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f0\\u1700-\\u170c\\u170e-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176c\\u176e-\\u1770\\u1772\\u1773\\u1780-\\u17d3\\u17d7\\u17dc\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18aa\\u18b0-\\u18f5\\u1900-\\u191c\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u19d0-\\u19d9\\u1a00-\\u1a1b\\u1a20-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1aa7\\u1b00-\\u1b4b\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1bf3\\u1c00-\\u1c37\\u1c40-\\u1c49\\u1c4d-\\u1c7d\\u1cd0-\\u1cd2\\u1cd4-\\u1cf6\\u1d00-\\u1de6\\u1dfc-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u200c\\u200d\\u203f\\u2040\\u2054\\u2071\\u207f\\u2090-\\u209c\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2119-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u212d\\u212f-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d7f-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u2de0-\\u2dff\\u2e2f\\u3005-\\u3007\\u3021-\\u302f\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u3099\\u309a\\u309d-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua62b\\ua640-\\ua66f\\ua674-\\ua67d\\ua67f-\\ua697\\ua69f-\\ua6f1\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua78e\\ua790-\\ua793\\ua7a0-\\ua7aa\\ua7f8-\\ua827\\ua840-\\ua873\\ua880-\\ua8c4\\ua8d0-\\ua8d9\\ua8e0-\\ua8f7\\ua8fb\\ua900-\\ua92d\\ua930-\\ua953\\ua960-\\ua97c\\ua980-\\ua9c0\\ua9cf-\\ua9d9\\uaa00-\\uaa36\\uaa40-\\uaa4d\\uaa50-\\uaa59\\uaa60-\\uaa76\\uaa7a\\uaa7b\\uaa80-\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaef\\uaaf2-\\uaaf6\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uabc0-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe00-\\ufe0f\\ufe20-\\ufe26\\ufe33\\ufe34\\ufe4d-\\ufe4f\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff10-\\uff19\\uff21-\\uff3a\\uff3f\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc]')\n\n        return (ch === 36) || (ch === 95) ||  // $ (dollar) and _ (underscore)\n            (ch >= 65 && ch <= 90) ||         // A..Z\n            (ch >= 97 && ch <= 122) ||        // a..z\n            (ch >= 48 && ch <= 57) ||         // 0..9\n            (ch === 92) ||                    // \\ (backslash)\n            ((ch >= 0x80) && NonAsciiIdentifierPart.test(String.fromCharCode(ch)));\n    }\n\n    function parseIdentityEscape() {\n        // IdentityEscape ::\n        //      SourceCharacter but not IdentifierPart\n        //      <ZWJ>\n        //      <ZWNJ>\n\n        var ZWJ = '\\u200C';\n        var ZWNJ = '\\u200D';\n\n        var res;\n\n        if (!isIdentifierPart(lookahead())) {\n            return createEscaped('identifier', incr());\n        }\n\n        if (match(ZWJ)) {\n        //      <ZWJ>\n            return createEscaped('identifier', ZWJ);\n        } else if (match(ZWNJ)) {\n        //      <ZWNJ>\n            return createEscaped('identifier', ZWNJ);\n        }\n\n        return null;\n    }\n\n    function parseCharacterClass() {\n        // CharacterClass ::\n        //      [ [lookahead ∉ {^}] ClassRanges ]\n        //      [ ^ ClassRanges ]\n\n        var res, from = pos;\n        if (res = matchReg(/^\\[\\^/)) {\n            res = parseClassRanges();\n            skip(']');\n            return createCharacterClass(res, true, from, pos);\n        } else if (match('[')) {\n            res = parseClassRanges();\n            skip(']');\n            return createCharacterClass(res, false, from, pos);\n        }\n\n        return null;\n    }\n\n    function parseClassRanges() {\n        // ClassRanges ::\n        //      [empty]\n        //      NonemptyClassRanges\n\n        var res;\n        if (current(']')) {\n            return createEmpty();\n        } else {\n            res = parseNonemptyClassRanges();\n            if (!res) {\n                throw expected('nonEmptyClassRanges');\n            }\n            return res;\n        }\n    }\n\n    function parseHelperClassRanges(atom) {\n        var from = pos, to, res;\n        if (current('-') && !next(']')) {\n        //      ClassAtom - ClassAtom ClassRanges\n            skip('-');\n\n            res = parseClassAtom();\n            if (!res) {\n                throw expected('classAtom');\n            }\n            to = pos;\n            var classRanges = parseClassRanges();\n            if (!classRanges) {\n                throw expected('classRanges');\n            }\n            return [createClassRange(atom, res, from, to)].concat(classRanges);\n        }\n\n        res = parseNonemptyClassRangesNoDash();\n        if (!res) {\n            throw expected('nonEmptyClassRangesNoDash');\n        }\n\n        return [atom].concat(res);\n    }\n\n    function parseNonemptyClassRanges() {\n        // NonemptyClassRanges ::\n        //      ClassAtom\n        //      ClassAtom NonemptyClassRangesNoDash\n        //      ClassAtom - ClassAtom ClassRanges\n\n        var atom = parseClassAtom();\n        if (!atom) {\n            throw expected('classAtom');\n        }\n\n        if (current(']')) {\n        //      ClassAtom\n            return [atom];\n        }\n\n        //      ClassAtom NonemptyClassRangesNoDash\n        //      ClassAtom - ClassAtom ClassRanges\n        return parseHelperClassRanges(atom);\n    }\n\n    function parseNonemptyClassRangesNoDash() {\n        // NonemptyClassRangesNoDash ::\n        //      ClassAtom\n        //      ClassAtomNoDash NonemptyClassRangesNoDash\n        //      ClassAtomNoDash - ClassAtom ClassRanges\n\n        var res = parseClassAtom();\n        if (!res) {\n            throw expected('classAtom');\n        }\n        if (current(']')) {\n            //      ClassAtom\n            return res;\n        }\n\n        //      ClassAtomNoDash NonemptyClassRangesNoDash\n        //      ClassAtomNoDash - ClassAtom ClassRanges\n        return parseHelperClassRanges(res);\n    }\n\n    function parseClassAtom() {\n        // ClassAtom ::\n        //      -\n        //      ClassAtomNoDash\n        if (match('-')) {\n            return createCharacter('-');\n        } else {\n            return parseClassAtomNoDash();\n        }\n    }\n\n    function parseClassAtomNoDash() {\n        // ClassAtomNoDash ::\n        //      SourceCharacter but not one of \\ or ] or -\n        //      \\ ClassEscape\n\n        var res;\n        if (res = matchReg(/^[^\\\\\\]-]/)) {\n            return createCharacter(res[0]);\n        } else if (match('\\\\')) {\n            res = parseClassEscape();\n            if (!res) {\n                throw expected('classEscape');\n            }\n            return res;\n        }\n    }\n\n    function syntaxError(str) {\n        return new Error('SyntaxError: ' + str);\n    }\n\n    function expected(str) {\n        return new Error('Expected: ' + str);\n    }\n\n    try {\n        var result = parseDisjunction();\n        result.lastMatchIdx = lastMatchIdx;\n    } catch(e) {\n        return {\n            error: e.message\n        };\n    }\n\n    if (result.to !== str.length) {\n        return {\n            error: 'Could not parse entire input - got stuck.'\n        };\n    }\n\n    return result;\n}\n\nif (typeof exports !== 'undefined') {\n    exports.parse = parse;\n} else {\n    // function testParse(str, expected) {\n    //     if (JSON.stringify(parse(str)) !== expected) {\n    //         console.error('Failure parsing string %s', str);\n    //         console.log('expected', expected, 'got', JSON.stringify(parse(str)));\n    //     } else {\n    //         console.log('PASSED PARSE TEST');\n    //     }\n    // }\n\n\n\n    // testParse('a', '{\"type\":\"alternative\",\"terms\":[{\"type\":\"patternCharacter\",\"data\":\"a\",\"quantifier\":false}]}');\n    // testParse('a|bc', '{\"type\":\"disjunction\",\"alternatives\":[{\"type\":\"alternative\",\"terms\":[{\"type\":\"patternCharacter\",\"data\":\"a\",\"quantifier\":false}]},{\"type\":\"alternative\",\"terms\":[{\"type\":\"patternCharacter\",\"data\":\"b\",\"quantifier\":false},{\"type\":\"patternCharacter\",\"data\":\"c\",\"quantifier\":false}]}]}');\n    // testParse('[a]', '{\"type\":\"alternative\",\"terms\":[{\"type\":\"characterClass\",\"classRanges\":{\"type\":\"classAtom\",\"value\":\"a\"},\"quantifier\":false}]}');\n    // testParse('[a-]', '{\"type\":\"alternative\",\"terms\":[{\"type\":\"characterClass\",\"classRanges\":[{\"type\":\"classAtom\",\"value\":\"a\"},{\"type\":\"classAtom\",\"value\":\"-\"}],\"quantifier\":false}]}');\n}\n\n\n//@ sourceURL=/lib/parser.js"
));

require.define("/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"// Whole-script strict mode syntax\n\"use strict\";\n\nvar getStartNodeFromPattern = require('./lib/exec').getStartNodeFromPattern;\nvar exec = require('./lib/exec').exec;\n\nfunction RegExpJS(pattern, flags) {\n    if (flags !== undefined) {\n        throw new Error('Flags are not supported yet');\n    }\n\n    this.$startNode = getStartNodeFromPattern(pattern);\n    this.lastIndex = 0;\n}\n\nRegExpJS.prototype.execDebug = function RegExpJSExec(str) {\n    return exec(str, this.$startNode, this.lastIndex);\n};\n\nRegExpJS.prototype.exec = function RegExpJSExec(str) {\n    var res = this.execDebug(str);\n\n    if (res.matches) {\n        return res.matches;\n    } else {\n        return null;\n    }\n};\n\nif (typeof window !== 'undefined') {\n    window.RegExpJS = RegExpJS;\n}\n\nexports.RegExpJS = RegExpJS;\n//@ sourceURL=/index.js"
));
require("/index.js");
})();
