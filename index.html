<html>
<head>
    <script src="build/browser.js"></script>
    <link rel="stylesheet" href="support/codemirror.css">
    <script src="support/codemirror.js"></script>

    <style type="text/css">
        .CodeMirror {
            border: 1px solid black;
        }
        .CodeMirror .cm-matchhighlight {
            background-color: orange;
            background-position: bottom;
            background-repeat: repeat-x;
        }
    </style>

    <style>
        span.highlight {
            background-color: orange;
        }

        span.booting {
            background-color: #C6C6EC;
        }

        #traces span {
            border: 1px solid gray;
            display: inline-block;
            width: 20px;
            text-align: center;
        }

        #traces span.failed {
            background-color: #FFB2A8;
        }

        #traces span:hover {
            border: 1px solid red;
            background-color: orange;
        }

        #traces span.matched {
            background-color: #4FC467;
        }

        #traces span.booting {
            background-color: #C6C6EC;
        }

        #traces .traceRun {
            margin-bottom: 3px;
        }
    </style>
</head>

<body>

<table width="500px">
    <tr>
        <td>RegExp:</td>
        <td>
            <input id="regexp" style="width:100%" value="a|b"></input>
            <!-- <input id="regexp" style="width:100%" value="b"></input> -->
            <!-- <input id="regexp" style="width:100%" value="(\w\w)*.*\w"></input> -->
            <span style="display:hidden" id="regexpRenderer"></span>
        </td>
    </tr>
    <tr>
        <td>Input:</td><td><textarea id="area" rows=5 style="width:100%;height:50px">foo: b</textarea></td>
    </tr>
    <tr>
        <td></td><td>
            <button id="newRegExpButton" onclick="newRegExp()" display="inline">New RegExp</button>
            <button id="matchItButton" onclick="matchIt()" >Match</button>
        </td>
    </tr>
    <tr id="resultTR">
        <td>Result:</td><td><textarea id="result" rows=5 style="width:100%"></textarea></td>
    </tr>
    <tr id="tracesTR">
        <td>Traces:</td>
        <td>
            <div id="traces" style="width:400px;overflow:auto"></div>
        </td>
    </tr>
    <tr id="parseTreeTR">
        <td>ParseTree:</td><td><textarea id="parseTree" rows=10 style="width:100%"></textarea></td>
    </tr>
</table>


<script>

var regExpDom = document.getElementById('regexp');
var regExpRendererDom = document.getElementById('regexpRenderer');
var newRegExpButton = document.getElementById('newRegExpButton');
var matchItButton = document.getElementById('newRegExpButton');

var infoTRs = ['resultTR', 'tracesTR', 'parseTreeTR'].map(function(str) { 
    return document.getElementById(str); 
});

function show(dom, inline) {
    dom.style.display = !inline ? 'block' : 'inline';
}
function hide(dom) {
    dom.style.display = 'none';
}

function showRegExpInput() {
    show(regExpDom);
    hide(regExpRendererDom);
    hide(newRegExpButton);
}

function showRegExpResult() {
    hide(regExpDom);
    show(regExpRendererDom);
    show(newRegExpButton, true);
}

var inputDom = document.getElementById('area');
var tracesDom = document.getElementById('traces');

var editor = CodeMirror.fromTextArea(inputDom, {
  lineNumbers: true
});
editor.setSize(null, '100px');
editor._overlay = null;

function makeOverlay(pos) {
    return {token: function(stream) {
        if (stream.pos == pos.from && pos.from !== pos.to) {
            stream.pos += pos.to - pos.from;
            return 'matchhighlight';
        }
        stream.next();
    }};
}

var lastRes = null;
var currentTrace = null;

function renderRegExpDom(from, to) {
    var shift = 4;
    var pre = '<span class="booting">';
    var boot = '.*?';
    var post = '</span>'
    var regexp = pre + boot + post + regExpDom.value;

    if (from >= 0) {
        shift = pre.length + boot.length + post.length;
    } else {
        shift = pre.length + 4;
    }

    var html = regexp.substring(0, from + shift) + '<span class="highlight">' + regexp.substring(from + shift, to + shift) + '</span>' + regexp.substring(to + shift);
    regExpRendererDom.innerHTML = html;
}

function reflectSelection(trace) {
    var selection;
    var pos;
    currentTrace = trace;
    if (!trace || !trace.node || !trace.node.parseEntry) {
        selection = { from: 0, to: 0 };
    } else {
        selection = trace.node.parseEntry;
    }
    if (trace) {
        pos = { from: trace.pos, to: trace.pos + 1 };
    } else {
        pos = { from: 0, to: 0 };
    }

    renderRegExpDom(selection.from, selection.to);

    if (editor._overlay) {
        editor.removeOverlay(editor._overlay);
    }
    editor.addOverlay(editor._overlay = makeOverlay(pos))
}

function reflectTreeSelection() {
    var ui = ref.data.ui;
    // Get the data used to create the hovered or if no hoverd node present
    // the current selected node.
    var traceId = (ui.hovered || ui.selected)[0].getAttribute('data-trace-id');
    var trace = lastRes.traces.data.traceHash[traceId];

    reflectSelection(trace);
}

tracesDom.addEventListener('mouseover', function(e) {
    var target = e.target;
    var traceId = target.getAttribute('data-trace-id');
    var trace = lastRes.traces.data.traceHash[traceId];

    reflectSelection(trace);
})

function traceToHTML(traceNode) {
    if (traceNode == null) {
        return '';
    }
    var display = '';
    var className = '';
    if (traceNode.node.parseEntry == null) {
        display = '';
    } else {
        if (traceNode.node.type == 'GROUP_BEGIN') {
            display = ''; //(';
        } else if (traceNode.node.type == 'GROUP_END') {
            display = ''; //')';
        } else if (traceNode.node.type == 'BACK') {
            display = 'B';
            className = 'booting';
        } else {
            display = traceNode.node.parseEntry.bit;
        }
        if (traceNode.failed) {
            className = 'failed';
        } else if (traceNode.matched) {
            className = 'matched';
        } else if (traceNode.node.parseEntry.booting) {
            className = 'booting';
        }
    }

    var html = '';
    if (display) {
        html = '<span class="' + className + '" data-trace-id="' + traceNode.id + '">' + display + '</span>';
    }
    return traceToHTML(traceNode.previous) + html;
}

function newRegExp() {
    showRegExpInput();
}

function matchIt() {
    showRegExpResult();

    renderRegExpDom(0, 0);

    var regExp = new RegExpJS(regExpDom.value);
    var input = editor.getValue();

    try {
        var res = window.res = lastRes = regExp.execDebug(input, regexp);
    } catch (exp) {
        alert('Sorry: ' + exp);
        return;
    }

    var resOutput;
    if (res.matches) {
        resOutput = JSON.stringify(res.matches, null, 4);
    } else {
        resOutput = 'null';
    }

    var traceOutput = '';
    traceOutput += '<div>Steps: ' + (res.traces.data.nodeCounter - 3) + ', Backreferences: ' + res.traces.data.backrefCounter + '</div>';
    traceOutput += res.traces.filter(function(trace) {
        return trace.isEndTrace;
    }).map(function(trace) {
        var tail = trace[trace.length - 1];
        var html = traceToHTML(tail);
        return '<div class="traceRun"><nobr>' + html + '</nobr></div>';
    }).join('\n');
    tracesDom.innerHTML = traceOutput;

    document.getElementById('result').value = resOutput;
    document.getElementById('parseTree').value = JSON.stringify(res.parseTree, null, 4);
}

// runTests();
showRegExpInput();

window.onload = function() {
    matchIt();
}

</script>
</html>